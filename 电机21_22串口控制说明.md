# 电机21、22串口控制功能说明

## 功能概述
通过串口接收指令，直接控制电机21（头部偏航）和电机22（头部俯仰）转动到指定角度。

**特点**：
- ✅ 不依赖任何控制模式
- ✅ 自动应用当前模式的PID配置
- ✅ 实时响应，立即生效
- ✅ 支持DM和QC电机类型

---

## 修改的文件

| 文件 | 修改内容 |
|------|---------|
| `Core/APP/somnia/somnia.h` | 添加2个公开函数声明 |
| `Core/APP/somnia/somnia.c` | 实现 `somnia_set_motor_direct()` 和 `somnia_set_head_motors()` |
| `Core/HAL/driver/remote/python_controller.h` | 添加命令 `PYCTL_CMD_SET_MOTORS_21_22 = 0x10` |
| `Core/HAL/driver/remote/python_controller.c` | 添加命令处理逻辑 |

---

## 串口协议

### 数据包格式
```
[帧头][长度][命令][数据][校验]
  1B    1B    1B    8B    1B
```

### 字段说明
| 字段 | 值 | 说明 |
|------|-----|------|
| 帧头 | `0xAA` | 固定帧头 |
| 长度 | `0x0A` | 命令(1) + 数据(8) + 校验(1) = 10 |
| 命令 | `0x10` | PYCTL_CMD_SET_MOTORS_21_22（绝对角度）|
| 命令 | `0x11` | PYCTL_CMD_SET_MOTORS_21_22_DELTA（增量角度）|
| 数据 | 8字节 | 电机21角度(float,4B) + 电机22角度(float,4B) |
| 校验和 | 1字节 | 命令+数据所有字节的和（模256） |

**数据格式**：
- 角度单位：弧度
- 浮点格式：IEEE 754单精度浮点，小端序
- 角度范围：±12.566弧度（约 ±720°）

**两种模式**：
1. **绝对角度模式**（命令 0x10）：直接设置电机到指定角度
2. **增量角度模式**（命令 0x11）：发送增量，目标角度 = 当前位置 + 增量

---

## 使用方法

### Python示例

```python
import struct
import serial

# 打开串口（根据实际情况修改）
ser = serial.Serial('COM3', 115200, timeout=1)

def send_motor_angles(yaw, pitch):
    """
    发送头部电机控制指令
    :param yaw: 电机21角度（弧度）
    :param pitch: 电机22角度（弧度）
    """
    # 转换为4字节小端float
    yaw_bytes = struct.pack('<f', yaw)
    pitch_bytes = struct.pack('<f', pitch)

    # 构建数据包
    header = 0xAA
    cmd = 0x10
    payload = yaw_bytes + pitch_bytes  # 8字节数据
    checksum = (cmd + sum(payload)) % 256
    length = 1 + len(payload) + 1  # 10字节

    packet = bytes([header, length, cmd]) + payload + bytes([checksum])

    # 发送
    ser.write(packet)
    print(f"已发送: Yaw={yaw:.3f}rad, Pitch={pitch:.3f}rad")

def build_delta_packet(yaw_delta, pitch_delta):
    """
    构建增量控制数据包
    :param yaw_delta: 电机21角度增量（弧度）
    :param pitch_delta: 电机22角度增量（弧度）
    :return: 完整数据包
    """
    # 转换为4字节小端float
    yaw_bytes = struct.pack('<f', yaw_delta)
    pitch_bytes = struct.pack('<f', pitch_delta)

    # 构建数据包（命令0x11：增量模式）
    header = 0xAA
    cmd = 0x11
    payload = yaw_bytes + pitch_bytes  # 8字节数据
    checksum = (cmd + sum(payload)) % 256
    length = 1 + len(payload) + 1  # 10字节

    packet = bytes([header, length, cmd]) + payload + bytes([checksum])
    return packet

# 测试：头部转动
send_motor_angles(0.5, 0.0)   # 右转
ser.close()

# === 增量模式示例 ===

# 示例1：相对当前位置移动
# 让电机21右转0.2弧度，电机22抬头0.1弧度
send_motor_angles(0.5, 0.0)   # 先移动到一个参考位置
time.sleep(0.5)  # 等待稳定
ser.write(build_delta_packet(0.2, 0.1))  # 发送增量
print("已发送增量：Yaw=+0.2rad, Pitch=+0.1rad")

# === 增量模式示例 ===

# 示例1：相对当前位置移动
# 让电机21右转0.2弧度，电机22抬头0.1弧度
send_motor_angles(0.5, 0.0)   # 先移动到一个参考位置
time.sleep(0.5)  # 等待稳定
ser.write(build_delta_packet(0.2, 0.1))  # 发送增量
print("已发送增量：Yaw=+0.2rad, Pitch=+0.1rad")

# 示例2：连续增量控制（摇杆模拟）
# 持续发送小幅增量，模拟摇杆控制
print("开始增量控制测试...")
delta_yaws = [0.1, 0.1, 0.05, 0.05, 0.0, -0.05, -0.05, -0.1, -0.1]  # 循环：左右转动
delta_pitches = [0.05, 0.0, 0.0, -0.05]  # 循环：上下转动

delta_index = 0
for i in range(10):  # 测试10次
    yaw_delta = delta_yaws[delta_index % len(delta_yaws)]
    pitch_delta = delta_pitches[delta_index % len(delta_pitches)]
    
    ser.write(build_delta_packet(yaw_delta, pitch_delta))
    print(f"步{i+1}: 增量 Yaw={yaw_delta:+.3f}, Pitch={pitch_delta:+.3f}")
    time.sleep(0.3)
    
    delta_index += 1

ser.close()
print("增量控制测试完成！")
```

### C语言示例

```c
#include <stdint.h>
#include <string.h>

void send_head_motors(float yaw, float pitch) {
    uint8_t packet[13];

    packet[0] = 0xAA;  // 帧头
    packet[1] = 0x0A;  // 长度
    packet[2] = 0x10;  // 命令

    // 复制角度数据（小端序）
    memcpy(&packet[3], &yaw, 4);    // 电机21角度
    memcpy(&packet[7], &pitch, 4);   // 电机22角度

    // 计算校验和
    uint8_t checksum = 0;
    for (int i = 2; i < 11; i++) {
        checksum += packet[i];
    }
    packet[11] = checksum;

    // 发送串口
    uart_send(packet, 12);
}
```

---

## 常用角度参考

| 角度描述 | 弧度值 | 角度值 |
|---------|--------|--------|
| 零位 | 0.0 | 0° |
| 右转45° | 0.785 | 45° |
| 左转45° | -0.785 | -45° |
| 右转90° | 1.571 | 90° |
| 左转90° | -1.571 | -90° |
| 抬头45° | 0.785 | 45° |
| 低头45° | -0.785 | -45° |

### 弧度转换公式
```python
# 角度转弧度
rad = deg * 3.14159 / 180.0

# 弧度转角度
deg = rad * 180.0 / 3.14159
```

---

## API函数说明

### 1. somnia_set_head_motors(yaw, pitch)
```c
void somnia_set_head_motors(float yaw, float pitch);
```
- **功能**：同时设置电机21和22的角度
- **参数**：
  - `yaw`：电机21角度（弧度）
  - `pitch`：电机22角度（弧度）
- **用法**：串口命令自动调用此函数

### 2. somnia_set_motor_direct(index, position)
```c
void somnia_set_motor_direct(uint8_t index, float position);
```
- **功能**：设置任意电机的位置
- **参数**：
  - `index`：电机索引（0-21）
  - `position`：目标位置（弧度）
- **备注**：可用于控制其他电机

---

## 调试信息

### STM32返回日志
成功接收指令后，STM32会输出：
```
Set Head Motors - Yaw: 0.500 rad, Pitch: 0.300 rad
```

### 常见问题

| 问题 | 原因 | 解决方法 |
|------|------|---------|
| 电机无响应 | 电机未启用 | 检查 `somnia_motor_enabled[20]` 和 `somnia_motor_enabled[21]` |
| 电机无力 | 当前为RELAX模式 | 切换到ACTION或HOLD模式以获得刚度 |
| 角度超限 | 角度超出范围 | 确保角度在 ±12.566 弧度范围内 |
| 校验和错误 | 数据包格式错误 | 检查校验和计算逻辑 |

---

## 配置参数说明

电机的PID参数（`kp`, `kd` 等）会根据**当前模式**自动应用：

| 模式 | 配置来源 | kp值 | 说明 |
|------|----------|-------|------|
| RELAX | `somnia_motor_configs_relax` | 0 | 电机无力，可自由转动 |
| ACTION | `somnia_motor_configs_action` | 20 | 适合动作播放 |
| HOLD | `somnia_motor_configs_hardhold` | 100 | 强力维持当前位置 |
| SOFTHOLD | `somnia_motor_configs_softhold` | 10 | 柔和维持 |

**无需手动切换模式**，函数会自动使用当前模式的配置。

---

## 完整测试流程

```python
import serial
import struct
import time

ser = serial.Serial('COM3', 115200, timeout=1)

def send(yaw, pitch):
    # 构建数据包
    yaw_bytes = struct.pack('<f', yaw)
    pitch_bytes = struct.pack('<f', pitch)
    cmd = 0x10
    payload = yaw_bytes + pitch_bytes
    checksum = (cmd + sum(payload)) % 256
    packet = bytes([0xAA, 0x0A, cmd]) + payload + bytes([checksum])
    ser.write(packet)

# 测试序列
test_angles = [
    (0.0, 0.0),    # 零位
    (0.5, 0.0),    # 右转
    (-0.5, 0.0),   # 左转
    (0.0, 0.3),    # 抬头
    (0.0, -0.3),   # 低头
    (0.5, 0.3),    # 右转+抬头
    (0.0, 0.0),    # 回零位
]

for yaw, pitch in test_angles:
    send(yaw, pitch)
    time.sleep(1)  # 等待1秒

ser.close()
print("测试完成！")
```

---

## 修改日期
2026-01-17

## 作者
AI助手
